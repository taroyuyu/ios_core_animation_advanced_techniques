## 隐式绘制


&nbsp;&nbsp;&nbsp;&nbsp;图层的*寄宿图*可以通过Core Graphics实时绘制，也可以直接载入一个图片文件并赋值给`contents`属性，或事先绘制一个屏幕之外的`CGContext`上下文中。在之前的两章中我们讨论了这些场景下的优化。但是除了常见的显式创建寄宿图之外，你也可以通过以下三种方式隐式地创建一个*寄宿图*：1，使用特定的图层属性。2，特定的视图。3，特定的图层子类。

&nbsp;&nbsp;&nbsp;&nbsp;准确理解这种情况发生的时间和原因是很重要的，这样您就可以避免在不需要的情况下意外地引入软件绘图。

### 文本

&nbsp;&nbsp;&nbsp;&nbsp;**`CATextLayer`和`UILabel`都是直接将文本绘制在图层的*寄宿图*中**。事实上这两种方式用了完全不同的渲染方式：**在iOS 6及之前，`UILabel`用WebKit的HTML渲染引擎来绘制文本，而`CATextLayer`用的是Core Text.后者渲染更迅速，所以在所有需要绘制大量文本的情形下都优先使用`CATextLayer`吧**。但是**这两种方法都用了软件的方式绘制，因此他们实际上要比硬件加速合成方式要慢**。

&nbsp;&nbsp;&nbsp;&nbsp;在可能的情况下，**尽可能地避免改变那些包含文本的视图的frame，因为这样做的话文本就需要重绘**。例如，如果你想在图层的角落里显示一段静态的文本，但是这个图层经常改动，你就应该把文本放在一个子图层中。

### 光栅化

&nbsp;&nbsp;&nbsp;&nbsp;在第四章『视觉效果』中我们提到了`CALayer`的`shouldRasterize`属性，它可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的优化』中，它也是作为绘制复杂图层树结构的优化方法。

&nbsp;&nbsp;&nbsp;&nbsp;**启用shouldRasterize属性会使图层绘制到屏幕外图像中。 然后，该图像将被缓存并绘制，以代替实际图层的内容和子图层。 如果有很多子层，或者它们应用了复杂的效果，这通常比每帧重绘都要便宜。但最初生成栅格化图像需要时间，而且会消耗额外的内存**。

&nbsp;&nbsp;&nbsp;&nbsp;**当我们使用得当时，光栅化可以提供很大的性能优势**（如你在第12章所见），但是**一定要避免作用在内容不断变动的图层上启用光栅化，否则它缓存方面的好处就会消失，而且会消耗额外的内存，以至于性能变得更糟**。

&nbsp;&nbsp;&nbsp;&nbsp;为了检测你是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。
