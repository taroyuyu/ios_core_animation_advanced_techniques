## 图层与视图


&nbsp;&nbsp;&nbsp;&nbsp;如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对*视图*的概念比较熟悉。**一个*视图*就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够监听类似于鼠标点击或者触摸手势等用户输入**。***视图*可以相互嵌套以形成层次结构，每个*视图*管理其*子视图*的位置。**图1.1显示了一种典型的视图层级关系

<img src="./1.1.jpeg" alt="图1.1" title="图1.1" width="700"/>

图1.1 一个典型的iOS界面（左边）和其所对应的视图层级结构（右边）

&nbsp;&nbsp;**在iOS当中，所有的视图都从一个叫做`UIVIew`的基类派生而来，`UIView`可以处理触摸事件，可以支持基于*Core Graphics*绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画**。

你可能没有意识到的是，这些任务的大多数并不是由UIView自身进行处理。渲染、布局和动画都是由Core Animation框架中一个叫做CALayer的类管理的。

### CALayer
`CALayer`类在概念上和`UIView`类似，是一个能组织成层级关系的矩形块，同时也可以包含一些内容（像图片，文本或者背景色），并且由*父图层*管理*子图层*的位置。它们有一些方法和属性用来做动画和变换。和`UIView`最大的不同是`CALayer`不处理用户的交互。

虽然`CALayer`提供了一些方法用于判断一个点是否在图层的范围之内（具体见第三章，“图层的几何学”）,但是它并不能响应事件，也没有*响应链*的概念（iOS用来在视图层级结构中传送触摸事件的机制）。

### 平行的层级关系
&nbsp;&nbsp;&nbsp;&nbsp;每一个`UIview`都有一个`layer`(`CALayer`类型)属性，也就是所谓的*backing layer*，*视图*的职责就是创建并管理这个图层，以确保当子视图被添加到视图层次结构中或从视图层次结构中移除时，子视图所关联的图层在对应的图层层次结构中有相同的操作（见图1.2）。
<img src="./1.2.jpeg" alt="图1.2" title="图1.2" width="700"/>
图1.2 图层层次结构（左边）以及对应的视图层次结构（右边）

&nbsp;&nbsp;&nbsp;&nbsp;实际上这些视图背后所有关联的图层才是真正负责在屏幕上显示和执行动画操作，`UIView`仅仅是对它的一个封装，并提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。

&nbsp;&nbsp;&nbsp;&nbsp;但是为什么iOS要基于`UIView`和`CALayer`提供两个平行的层次结构呢？为什么不用一个简单的层次结构来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和`UIView`，但是Mac OS有AppKit和`NSView`的原因。他们功能上很相似，但是在实现上有着显著的区别。

&nbsp;&nbsp;&nbsp;&nbsp;相比之下，绘图、布局和动画等概念既适用于iPhone和iPad等触屏设备，也适用于笔记本电脑和台式机。通过将这一功能的逻辑分离到独立的Core Animation框架中，苹果能够在iOS和Mac OS之间共享代码，让苹果自己的操作系统开发团队和针对这两个平台开发应用的第三方开发者的工作变得更简单。

&nbsp;&nbsp;&nbsp;&nbsp;实际上，这种层次结构并不是只有两个，而是四个，每一个都扮演不同的角色，除了视图层次结构和图层层次结构之外，还存在*呈现树(presentation tree)*和*渲染树(render tree)*。我们将在第七章“隐式动画”和第十二章“性能调优”分别对这两个层次结构进行讨论。


