## CPU VS GPU

&nbsp;&nbsp;&nbsp;&nbsp;关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，这些都是可编程的芯片可以运行(或多或少)任意软件，但是由于历史原因，我们倾向于将由CPU完成的工作称为“用软件方式处理”，将由GPU完成的工作称为"用硬件方式处理"。

&nbsp;&nbsp;&nbsp;&nbsp;总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常用硬件(GPU)会更快，因为GPU针对图形中使用的浮点数学运算进行了高度并行优化。出于这个原因，我们希望将尽可能多的屏幕渲染工作卸给硬件。问题是GPU并没有无限的处理能力，一旦它被用满了，性能就会开始下降(即使CPU没有被充分利用)。

&nbsp;&nbsp;&nbsp;&nbsp;大多数动画性能优化都是关于合理地利用GPU和CPU，使得它们都不会超出负荷。于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。

### 动画的舞台

&nbsp;&nbsp;&nbsp;&nbsp;Core Animation处在iOS的核心地位：应用内和应用间都会用到它。一个简单的动画可能同步显示多个app的内容，例如当在iPad上多个程序之间使用手势切换，会使得多个程序同时显示在屏幕上。在一个特定的应用中用代码实现它是没有意义的，因为在iOS中不可能实现这种效果（App都是被沙箱管理，不能访问别的视图）。

&nbsp;&nbsp;&nbsp;&nbsp;动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的*渲染服务*。在iOS5和之前的版本是*SpringBoard*进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做`BackBoard`。

当你执行一个动画时，这个过程分为四个独立的阶段:

* **布局(Layout)** - **这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段**。
* **显示/绘制(Display)** - **这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的`-drawRect:`和`-drawLayer:inContext:`方法的调用路径**。
* **准备(Prepare)** - **这是Core Animation准备发送动画数据到渲染服务器的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点**。
* **提交(Commit)** - 这是最后的阶段，**Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务器进行显示**。

注：*渲染服务器*是一个单独的进程，App与*渲染服务器*进行通信需要通过进程间通信（IPC）。

&nbsp;&nbsp;&nbsp;&nbsp;**但是这些仅仅阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做*渲染树(render tree)*的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作**：

* **对所有的图层属性计算中间值，并设置OpenGL几何形状（纹理化的三角形）来执行渲染**

* **在屏幕上渲染可见的三角形**

&nbsp;&nbsp;&nbsp;&nbsp;**所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它**。

这并不是真正的问题，因为在布局和显示阶段，你需要决定哪些工作需要在CPU上提前完成，哪些工作需要传递给GPU。那么你如何做出这个决定呢?

#### GPU相关的操作

&nbsp;&nbsp;&nbsp;&nbsp;GPU针对特定的任务进行了优化：**获取图像和几何图形(三角形)，执行变换，应用纹理和混合，然后将它们放到屏幕上**。现代iOS设备上的可编程GPU在在如何执行这些操作方面提供了很大的灵活性，但Core Animation框架并没有提供直接的接口。除非你想绕开Core Animation，编写自己的OpenGL着色器，否则你基本上会被一组固定的东西卡住，这些东西都是硬件加速的，而其他的一切都必须在CPU上的软件中完成。

&nbsp;&nbsp;&nbsp;&nbsp;一般来说，**CALayer的大多数属性都是使用GPU绘制的**。例如，**如果你设置图层的背景颜色或者边框颜色，那么这些可以使用有色三角形有效地绘制**。**如果你将一个图像作为图层的*寄宿图*(即赋值给图层的*contents*属性)，不管我们不会对该图像进行缩放和裁剪，该图像都会被带纹理的三角形绘制出来，而不需要经过*软件绘图(即使用CPU进行绘制)***。

&nbsp;&nbsp;&nbsp;&nbsp;但是有一些事情会降低（主要是基于GPU的）图层的绘制效率，比如：

* **几何图形太多** - 太多的三角形需要进行变换操作和光栅化操作，以致于处理器无法应付。现代iOS设备的图形芯片可以处理数百万个三角形，所以当涉及到Core Animation时，几何图形实际上不太可能成为GPU的瓶颈。**由于图层在显示之前必须经过*预处理*(由CPU进行处理)并通过IPC发送到渲染服务器**，但**图层是相当"重"的对象，由几个子对象(子图层)组成**，所以**太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数**（见本章后续“CPU相关操作”）。

* **重绘操作太多** - **主要由重叠的半透明图层引起**。**GPU的*[像素填充率](https://zh.wikipedia.org/wiki/填充率)*（用颜色填充像素的比率）是有限的，所以需要避免过度*重绘*情况（在每帧中多次填充相同的像素）的发生**。现代iOS设备的GPU能够很好地应对重绘情况;即使是iPhone 3GS也可以在不低于60帧/秒的情况下处理整个屏幕2.5倍的重绘(这意味着你可以在不影响性能的情况下绘制一个半屏幕的冗余信息)，而更新的设备可以处理更多。

* **离屏绘制** - **当一个特定的效果不能通过直接在屏幕上绘图来实现，而必须先在*离屏图像上下文(offscreen image context)*中绘图时，就会出现这种情况**。***离屏绘制*是一个通用术语，可能适用于CPU或基于GPU的绘图，但无论是哪种方式，它涉及到为*离屏图像(offscrren image)*分配额外的内存和在绘图上下文之间切换，这两者都会降低GPU性能**。**对于特定的图层效果，比如圆角，图层蒙版，阴影或者是图层光栅化都会强制Core Animation在*屏幕外(offscreen)*预渲染图层**。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。

  https://medium.com/@ninja31312/what-is-offscreen-rendering-636df95225be

  https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_offscreen/opengl_offscreen.html

  https://en.wikipedia.org/wiki/Framebuffer

* **过大的图片** - **如果试图绘制的图像的大小大于GPU支持的最大纹理尺寸（2048x2048或者4096x4096，具体取决于设备），就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能**。

#### CPU相关的操作

&nbsp;&nbsp;&nbsp;&nbsp;**Core Animation中大部分由CPU处理工作的都发生在动画开始之前**。**这是好事，因为这意味着它不会影响到帧率(动画看起来会很流畅)。但又是坏事，因为它可能会延迟动画的开始时间，让你的界面看起来会没有响应**。

（所以Core Animation中的动画的执行过程，比如帧的更新，不是在当前App进程内完成的是吗？）

&nbsp;&nbsp;&nbsp;&nbsp;以下CPU的操作都会延迟动画的开始时间：

* **布局计算** - **如果你的视图层级过于复杂，当视图呈现或者被修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的*AutoLayout*机制时尤为明显，它比*AutoResizing*更耗费CPU**。

* **视图懒加载** - **iOS只会当视图控制器的视图即将显示到屏幕上时才会加载它。这对内存使用和App启动时间很有好处，但是如果点击按钮突然导致在任何东西出现在屏幕上之前必须完成大量工作，那么响应性就会受到影响。如果控制器从数据库中获取数据，或者视图从nib文件中加载，或者包含图像，这也会导致IO工作，这可能会比普通CPU操作慢几个数量级**(见“IO绑定操作”一节，在本章后面)。

* **Core Graphics绘制操作** - **如果对重写了UIView的`-drawRect:`方法，或者实现了`CALayerDelegate`的`-drawLayer:inContext:`方法，那么在实际绘制任何东西之前会引入一个显著的性能开销**。**为了支持对图层内容的任意绘制，Core Animation必须在内存中创建一个与视图尺寸相等的*寄宿图***。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，**Core Graphics绘制本身会十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好**。

* **图片解码** - **压缩后的图像文件，如png或jpeg，比同等的未压缩位图要小得多。但是在图像绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用`UIImageView`）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间**。

&nbsp;&nbsp;&nbsp;&nbsp;当图层被成功打包（对图层数据进行序列化），发送到渲染服务器之后，CPU仍然要做如下工作（由渲染服务器执行）：为了显示屏幕上的图层，Core Animation必须遍历*渲染树(render tree)*中的每个可见图层并将其转换成一对*纹理三角形(textured triangles)*供GPU使用。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作量和图层个数成正比，所以层次结构中的太多层将间接导致每帧额外的CPU减速，即使这些工作发生在应用程序之外（发生在渲染服务器中）。

#### IO相关操作

&nbsp;&nbsp;&nbsp;&nbsp;还有一项没涉及的就是IO相关工作。**在这里，IO（输入/输出）指的是例如对闪存或者网络接口等硬件访问。一些动画可能需要从flash（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或图像的旋转，这可能太大存储在内存中，所以需要动态加载旋转滚动**。

&nbsp;&nbsp;&nbsp;&nbsp;IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪明但难以正确处理的技术来解决这个问题，例如多线程，缓存和预加载（提前加载当前不需要的资源，但是之后**可能**需要用到）。这些技术将会在第14章中讨论。
